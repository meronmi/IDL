; _____________________________________________________________________________________________
;
; NAME:
;   PHENOLOGY_THRESHOLD_OWN
;
; PURPOSE:
;   Extraction of SOS and EOS using the threshold method of White. Here we use input of an
;   average cycle to determine which cycle to look at. From the average cycle we extracted moment
;   of min and max. Here we search for SOS between [min-3periods:max+3periods]. Always two years
;   of data are evaluated in one loop to cover all possible cycles. The output for a specific
;   year may thus be > 365 meaning that SOS is in the following year. This would be needed also
;   to allow for small changes between december and january.
;
; INPUT:
;   1) The Savitzky-Golay filtered BIL-stack of NDVI values
;   2) A file indicating the min & max moments and cycle, generated by AVG_SEASONS_MAXMIN.pro
;   3) A file with the LTA NDVI for masking out areas
;
; OUTPUT:
;   6 Files per cycle:
;     SOS: Start of season in Julian day   (valid range 1-729)
;     EOS: End of season in Julian day     (valid range 1-729)
;     LOS: Length of season in Julian day
;     MOS: moment of maximum NDVI of season in Julian day
;     maxNDVI: maximum NDVI of season
;     cumNDVI: cumulative NDVI of season    (only one which is in longword integer)
;
; CALLING SEQUENCE:
;   PHENOLOGY_THRESHOLD_OWN
;
; MODIFICATION HISTORY:
;   Written by:  Anton Vrieling, February 2009
;   Revised by Anton Vrieling for NDVI3g, August 2012
;
; _____________________________________________________________________________________________


PRO PHENOLOGY_THRESHOLD_OWN_GLOBAL

STARTTIME = SYSTIME(1)

minmaxPath='G:\IMAGES\GIMMS_NDVI3g_global\processing\'
NDVIpath  ='G:\IMAGES\GIMMS_NDVI3g_global\processing\'
outPath   ='G:\IMAGES\GIMMS_NDVI3g_global\processing\phenoVrieling\'
minmaxFile = minmaxPath + 'global_GIMMS_Average_seasons_minmax.stk'
NDVIFile   = NDVIpath + 'global_NDVI3g_filteredSG.stk'
avgNDVIfile = NDVIpath + 'global_NDVI3g_filteredSG_Average_Signature.stk
IF FILE_TEST(outPath, /DIRECTORY) eq 0 then FILE_MKDIR, outPath

sosFile1 = outPath + 'SOS_cycle1_threshold.stk'
eosFile1 = outPath + 'EOS_cycle1_threshold.stk'
losFile1 = outPath + 'LOS_cycle1_threshold.stk'
mosFile1 = outPath + 'MOS_cycle1_threshold.stk'
maxFile1 = outPath + 'maxNDVI_cycle1_threshold.stk'
cumFile1 = outPath + 'cumNDVI_cycle1_threshold.stk'
sosFile2 = outPath + 'SOS_cycle2_threshold.stk'
eosFile2 = outPath + 'EOS_cycle2_threshold.stk'
losFile2 = outPath + 'LOS_cycle2_threshold.stk'
mosFile2 = outPath + 'MOS_cycle2_threshold.stk'
maxFile2 = outPath + 'maxNDVI_cycle2_threshold.stk'
cumFile2 = outPath + 'cumNDVI_cycle2_threshold.stk'

fileList =[sosFile1,eosFile1,losFile1,mosFile1,maxFile1,cumFile1,sosFile2,eosFile2,losFile2,mosFile2,maxFile2,cumFile2]
FOR f=0,N_ELEMENTS(fileList)-1,1L DO BEGIN
 IF FILE_TEST(fileList[f]) eq 1 THEN FILE_DELETE, fileList[f]
ENDFOR

ns = 4320
nl = 1658                           ; number of lines
nb =  780              			        ; number of bands
np=24                               ; number of periods in one year
startYear=1982                      ; startyear of analysis
endYear=2012                        ; endyear of analysis (not last year of data, which should be one more = 2006!)
repetitions = endYear-startYear+1   ; number of years that can be analyzed
offsetFile = 12                     ; as file is starting July
tolerance = 3                       ; the tolerance, meaning that Min and Max may be searched 3 periods before average min and 3 periods after max
offsetMinMaxFile = [0,2]            ; offset in minmaxFile for cycle 1 & 2 respectively

; create a standard list of dates (month & day) for 15-day data
dates_m=[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12]
dates_d=[8,23,8,22,8,23,8,22,8,23,8,22,8,23,8,23,8,22,8,23,8,22,8,23]
dates_y=BYTARR(24)+1                   ; take year 1 as base
; now transform to two years
dates_m=[dates_m,dates_m]
dates_d=[dates_d,dates_d]
dates_y=[dates_y,dates_y+1]
datesJulian=JULDAY(dates_m,dates_d,dates_y) - JULDAY(1,1,1) + 1
datesJulian=[INTARR(tolerance),datesJulian]     ; to easen later processing when getting dates etc...

; Create access to input files
OPENR, lun1, minmaxFile, /GET_LUN
minmaxAssoc = ASSOC(lun1, BYTARR(ns,5))
OPENR, lun2, NDVIFile, /GET_LUN
ndviAssoc = ASSOC(lun2, INTARR(ns,nb))
OPENR, lun3, avgNDVIfile, /GET_LUN
avgNdviAssoc = ASSOC(lun3, INTARR(ns,np))

; Open output files for writing
OPENW,  W1, sosFile1, /GET_LUN, /APPEND
OPENW,  W2, eosFile1, /GET_LUN, /APPEND
OPENW,  W3, losFile1, /GET_LUN, /APPEND
OPENW,  W4, mosFile1, /GET_LUN, /APPEND
OPENW,  W5, maxFile1, /GET_LUN, /APPEND
OPENW,  W6, cumFile1, /GET_LUN, /APPEND
OPENW,  W7, sosFile2, /GET_LUN, /APPEND
OPENW,  W8, eosFile2, /GET_LUN, /APPEND
OPENW,  W9, losFile2, /GET_LUN, /APPEND
OPENW, W10, mosFile2, /GET_LUN, /APPEND
OPENW, W11, maxFile2, /GET_LUN, /APPEND
OPENW, W12, cumFile2, /GET_LUN, /APPEND

FOR j=0,nl-1,1L DO BEGIN                             ; Loop over lines
  minmaxLine = minmaxAssoc[j]                        ; get line with cycle, and moments of min1, max1, min2, max2
  ;initiate datalines for writing later
  sosLine1 = INTARR(ns,repetitions) - 1              ; no value is set to -1
  eosLine1 = INTARR(ns,repetitions) - 1              ; no value is set to -1
  losLine1 = INTARR(ns,repetitions) - 1              ; no value is set to -1
  mosLine1 = INTARR(ns,repetitions) - 1              ; no value is set to -1
  maxNDVIline1 = INTARR(ns,repetitions) - 1          ; no value is set to -1
  cumNDVIline1 = LONARR(ns,repetitions) - 1          ; no value is set to -1
  sosLine2 = INTARR(ns,repetitions) - 1              ; no value is set to -1
  eosLine2 = INTARR(ns,repetitions) - 1              ; no value is set to -1
  losLine2 = INTARR(ns,repetitions) - 1              ; no value is set to -1
  mosLine2 = INTARR(ns,repetitions) - 1              ; no value is set to -1
  maxNDVIline2 = INTARR(ns,repetitions) - 1          ; no value is set to -1
  cumNDVIline2 = LONARR(ns,repetitions) - 1          ; no value is set to -1

  IF max(minmaxLine[*,1]) ne 0 THEN BEGIN               ; avoid processing lines of no data
    NDVIline = ndviAssoc[j]                             ; get line of NDVI data
    avgNDVIline=avgNdviAssoc[j]
    FOR year=startYear,endYear,1L DO BEGIN
      ; here we get 2 years of data for all samples in line
      NDVIyearsLine = NDVIline[*,offsetFile+(year-startYear)*np-tolerance:offsetFile+(year+2-startYear)*np-1]
      ; Loop over samples in line
      FOR i=0,ns-1,1L DO BEGIN
        minmaxPoint=TRANSPOSE(minmaxLine[i,*])           ; array with 5 attributes: #cycle, min1,max1,min2,max2
        NDVIyearsPoint = TRANSPOSE(NDVIyearsLine[i,*])   ; NDVI-array for 1 point (2 years + 'tolerance' periods before)
        avgNDVIPoint = TRANSPOSE(avgNDVIline[i,*])
        ; set up some conditions for masking (per year)
        ;test = MEAN(NDVIyearsPoint) gt 1500 and MEAN(NDVIyearsPoint) le 7500 AND max(NDVIyearspoint)-min(NDVIyearsPoint) ge 700 and STDDEV(NDVIyearsPoint)/MEAN(NDVIyearsPoint) gt 0.1
        test = MEAN(NDVIyearsPoint) gt 1200 and MEAN(NDVIyearsPoint) le 7500 AND max(NDVIyearspoint)-min(NDVIyearsPoint) ge 700 and STDDEV(NDVIyearsPoint)/MEAN(NDVIyearsPoint) gt 0.1
        ;test2 = MEAN(avgNDVIPoint) gt 1200 and MEAN(avgNDVIPoint) le 7500; AND max(avgNDVIPoint)-min(avgNDVIPoint) ge 600
        ;test=test*test2
        FOR cycle=1,2,1L DO BEGIN
          offset = offsetMinMaxFile[cycle-1]
          ; avoid processing points with no valid min1 and additionally avoid processing points with very low NDVI mean (some problems with islands)
          IF minmaxPoint[1+offset] ne 0 AND FIX(test) eq 1 THEN BEGIN
            ; now determine min and max in the window [min-3periods:max+3periods]
            ; minimum is determined after maximum to be sure it occurs before maximum
            ; final minOS and maxOS are recorrected for start, so they coincide with point in NDVIyearsPoint
            ;     ;start looking for Max halfway between min&max of general            ; here 2*tolerance to expand with 1 tolerance the search for max
            ;                                                           !                                   !
            startPointMaxSearch = (minmaxPoint[1+offset]+minmaxPoint[2+offset])/2 + tolerance -1    ;       !
            maxNDVIpoint = max(NDVIyearsPoint[startPointMaxSearch:minmaxPoint[2+offset]-1+2*tolerance],MaxOSpoint)
            maxOSpoint = maxOSpoint+startPointMaxSearch
            minNDVIpoint = min(NDVIyearsPoint[minmaxPoint[1+offset]-1:maxOSpoint],MinOSpoint)
            minOSpoint = minOSpoint+minmaxPoint[1+offset]-1

            ; Create a condition for the theoretically possible case that maxOSpoint is placed at same location as minOSpoint (descending line while usually should be ascending)
            ; Even maxOSpoint should be bigger to avoid problems (so +1)
            IF maxOSpoint gt minOSpoint+1 THEN BEGIN
              halfNDVIvalue   = FLOAT((maxNDVIpoint+minNDVIpoint)/2)+0.01   ; here we add 0.01 to be sure a point is never exactly equal
              ; now look for SOS
              IF minOSpoint eq 0 then minStart=1 ELSE minStart=minOSpoint   ; to avoid subscripting with -1
              FOR p=minStart,MaxOSpoint,1L DO BEGIN  ; using this loop, always the last value before maximum is selected as SOS
                IF NDVIyearsPoint[p] gt halfNDVIvalue AND NDVIyearsPoint[p-1] lt halfNDVIvalue THEN BEGIN
                  halfNDVI = FIX(halfNDVIvalue)
                  fraction = 1.*(halfNDVI - NDVIyearsPoint[p-1])/(NDVIyearsPoint[p]-NDVIyearsPoint[p-1])
                  sosPoint = fraction*(datesJulian[p]-datesJulian[p-1]) + datesJulian[p-1]
                  ; the first fraction of cumNDVI...
                  cumNDVIstartFraction = (1-fraction) * (NDVIyearsPoint[p]+halfNDVI)/2
                  startPeriod = p                     ; to use later for cumNDVI calculation
                ENDIF
              ENDFOR
              ; now look for EOS  ; remember p is now set at MaxOSpoint, so from here should be decreasing
              ; final p value is first index where NDVI < halfNDVIvalue
              ; we add two extra conditions: 1) p should not run out of timeseries, 2) Season length should be less than 20 periods
              WHILE NDVIyearsPoint[p] gt halfNDVIvalue AND p lt N_ELEMENTS(NDVIyearsPoint)-1 AND p lt startPeriod+20 DO p++
              IF p eq N_ELEMENTS(NDVIyearsPoint) OR p eq startPeriod+20 OR p-1 lt startPeriod THEN BEGIN
                sosPoint=-1 & maxNDVIpoint=-1 & eosPoint=-1 & losPoint=-1 & cumNDVIPoint=-1     ; for now we don't set other values to -1
              ENDIF ELSE BEGIN
                fraction = 1.*(NDVIyearsPoint[p-1]-halfNDVI)/(NDVIyearsPoint[p-1]-NDVIyearsPoint[p])
                eosPoint = fraction*(datesJulian[p]-datesJulian[p-1]) + datesJulian[p-1]
                losPoint = eosPoint-sosPoint
                ; the end fraction of cumNDVI
                cumNDVIendFraction = fraction * (NDVIyearsPoint[p-1]+halfNDVI)/2
                cumNDVIpoint = TOTAL(NDVIyearsPoint[startPeriod:p-1]) + cumNDVIstartFraction + cumNDVIendFraction
              ENDELSE

              ; write outputs to temporary line of data
              IF cycle eq 1 THEN BEGIN
                sosLine1[i,year-startYear] = FIX(sosPoint)
                eosLine1[i,year-startYear] = FIX(eosPoint)
                losLine1[i,year-startYear] = FIX(losPoint)
                mosLine1[i,year-startYear] = datesJulian[MaxOSpoint]        ; write moment of maximum to Line
                maxNDVIline1[i,year-startYear] = maxNDVIpoint               ; write maximum NDVI value
                cumNDVIline1[i,year-startYear] = LONG(cumNDVIpoint)
              ENDIF ELSE BEGIN
                sosLine2[i,year-startYear] = FIX(sosPoint)
                eosLine2[i,year-startYear] = FIX(eosPoint)
                losLine2[i,year-startYear] = FIX(eosPoint - sosPoint)
                mosLine2[i,year-startYear] = datesJulian[MaxOSpoint]        ; write moment of maximum to Line
                maxNDVIline2[i,year-startYear] = maxNDVIpoint               ; write maximum NDVI value
                cumNDVIline2[i,year-startYear] = LONG(cumNDVIpoint)
              ENDELSE
            ENDIF;condition that min and max moment fall at same point
          ENDIF  ;condition if there are valid points
        ENDFOR   ;both cycles
      ENDFOR     ;all samples in line
    ENDFOR       ;all years
  ENDIF          ;condition if there are any valid points at all

  ;writing one line of data for all samples and years (for each phenology attribute)
  WRITEU,  W1, sosLine1
  WRITEU,  W2, eosLine1
  WRITEU,  W3, losLine1
  WRITEU,  W4, mosLine1
  WRITEU,  W5, maxNDVILine1
  WRITEU,  W6, cumNDVILine1
  WRITEU,  W7, sosLine2
  WRITEU,  W8, eosLine2
  WRITEU,  W9, losLine2
  WRITEU, W10, mosLine2
  WRITEU, W11, maxNDVILine2
  WRITEU, W12, cumNDVILine2
ENDFOR

CLOSE, /ALL

; WRITE HEADERS FOR THE OUTPUTS
FOR f=0,N_ELEMENTS(fileList)-1, 1L DO BEGIN
  outfile = fileList[f]
  HEADER_OUT=STRMID(outfile,0,STRLEN(outfile)-3)+'hdr'
  IF FILE_TEST(HEADER_OUT) eq 1 THEN FILE_DELETE, HEADER_OUT
  OPENW, 3, HEADER_OUT
  printf,3,'ENVI'
  printf,3,'description = {'
  CASE outfile of
    sosFile1: printf,3,'  Start of season (SOS) for threshold method and first cycle in julian day}'
    eosFile1: printf,3,'  End of season (EOS) for threshold method and first cycle in julian day}'
    losFile1: printf,3,'  Length of season (LOS) for threshold method and first cycle in julian day}'
	  mosFile1: printf,3,'  Moment of maximum NDVI (MOS) for threshold method and first cycle in julian day}'
	  maxFile1: printf,3,'  Maximum NDVI-value of season (maxNDVI) for threshold method and first cycle}'
	  cumFile1: printf,3,'  Cumulated NDVI during season (cumNDVI) for first cycle}'
	  sosFile2: printf,3,'  Start of season (SOS) for threshold method and second cycle in julian day}'
    eosFile2: printf,3,'  End of season (EOS) for threshold method and second cycle in julian day}'
    losFile2: printf,3,'  Length of season (LOS) for threshold method and second cycle in julian day}'
	  mosFile2: printf,3,'  Moment of maximum NDVI (MOS) for threshold method and second cycle in julian day}'
	  maxFile2: printf,3,'  Maximum NDVI-value of season (maxNDVI) for threshold method and second cycle}'
	  cumFile2: printf,3,'  Cumulated NDVI during season (cumNDVI) for second cycle}'
  ENDCASE
  printf,3,'samples ='+STRCOMPRESS(ns)
  printf,3,'lines   ='+STRCOMPRESS(nl)
  printf,3,'bands   ='+STRCOMPRESS(repetitions)
  printf,3,'header offset = 0'
  printf,3,'file type = ENVI Standard'
  IF outfile NE cumFile1 AND outfile NE cumFile2 THEN printf,3,'data type = 2' ELSE printf,3,'data type = 3'
  printf,3,'interleave = bil'
  printf,3,'sensor type = AVHRR'
  printf,3,'byte order = 0'
  printf,3,'data ignore value = -1'
  printf,3,'map info = {Geographic Lat/Lon, 1.0000, 1.0000, -179.958333333333333333333, 82.1250, 0.08333333333333333333, 0.08333333333333333333, WGS-84, units=degrees}'
  printf,3,'band names = {'+ STRJOIN(STRCOMPRESS(INDGEN(endYear-startYear+1)+startYear, /REMOVE_ALL),', ')+'}'
  CLOSE, 3
ENDFOR


; Evaluation of processing time
ELAPSED_TIME = FIX(SYSTIME(1) - STARTTIME)
MINUTES = ELAPSED_TIME / 60
SECS=ELAPSED_TIME MOD 60
PRINT, 'PROCESSING TOOK :'+STRCOMPRESS(MINUTES)+' MINUTES AND'+STRCOMPRESS(SECS)+' SECONDS'
PRINT, 'FINISHED EXTRACTING PHENOLOGY USING THRESHOLD METHOD'

END ;Procedure PHENOLOGY_THRESHOLD_OWN