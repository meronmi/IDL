PRO RAPHAEL_pheno_v3

@cb_optimization.comm

buffer_plots = 1 ;(0 to see them)
extract_pheno = 1  ;with 0 just plots the input data in a single graph
k_sub_max = 4     ;subscript of the last index to consider 0 is only first, 1 is vh vv ratio, and so on
dlmtr = ','



;read the file. New format:
;y = CREATE_STRUCT('pointID', LONARR(ntot), 'dateJD', LONARR(ntot), 'x', FLTARR(ntot), 'y', FLTARR(ntot), 'nuts0', STRARR(ntot), $
;  'crop', STRARR(ntot), 'surveyDateJD', LONARR(ntot), 's12', BYTARR(ntot), $
;  'orbit', STRARR(ntot), 'CR', FLTARR(ntot), 'RVI', FLTARR(ntot), $
;  'NDVIm', FLTARR(ntot), 'NDVIsd', FLTARR(ntot))
;!!! BE CARE, THE FOLLOWING HAS TO MATCH WITH SAV STRUCTURE
fn_sav = 'D:\RAPHAEL_pheno_test\LUCAS_S1-S2_extraction_20190520_v3.sav'
RESTORE, fn_sav
;COMPULSORY TO USE '_' to separete the index and the orbit
selected_indices = ['NDVIm', 'CR_ad', 'RVI_ad', 'CR_a', 'RVI_a', 'CR_d', 'RVI_d']

tagNames = TAG_NAMES(y)
sub_tag_selected_indices = BYTARR(N_ELEMENTS(selected_indices))

FOR i = 0, N_ELEMENTS(selected_indices)-1 DO BEGIN
  tmp = STRSPLIT(selected_indices[i], '_', /EXTRACT)
  sub_tag_selected_indices[i] = WHERE(STRLOWCASE(tagNames) EQ STRLOWCASE(tmp[0]), count)
  IF (count EQ 0) THEN STOP
ENDFOR

use_time_constrains_per_crop = 1     ;set it to 1 to have time period (used by locate_largest_season_in_jd_range_v2) per crop
;time constrain per crop if required
IF (use_time_constrains_per_crop EQ 1) THEN BEGIN
  res = READ_CSV(FILE_DIRNAME(fn_sav) + '\time_constrains_per_crop.csv', HEADER=hdr)
  timeRangesPerCrop = rename_tags(res, TAG_NAMES(res), hdr)
ENDIF

cropTypes = y.crop[UNIQ(y.crop,SORT(y.crop))]
PRINT, 'n unique crops = ', STRING(N_ELEMENTS(cropTypes))
selected_crops = cropTypes
;put common wheat first for easy debug
selected_crops = [selected_crops[3], selected_crops[0:2], selected_crops[4:-1]]
PRINT, selected_crops

;create the output dir
stime = SYSTIME()
stimeStr = STRMID(stime,20,4) + STRMID(stime,4,3) + STRMID(stime,8,2)
dir_out = FILE_DIRNAME(fn_sav) + '\Results_' + stimeStr
IF FILE_SEARCH(dir_out) EQ '' THEN BEGIN
  FILE_MKDIR, dir_out
ENDIF ELSE BEGIN
  PRINT, 'Directory already exists, the program will overwrite it'
  FILE_MKDIR, dir_out
ENDELSE

;; set aside sd, do not consider it as index to be processed but as an ancillary info
;PRINT, 'Set aside NDVI_stdDev'
;indSD = WHERE(indices EQ 'NDVI_stdDev')
;indNonSD = WHERE(indices NE 'NDVI_stdDev')
;indexSD = indices[indSD]
;indexSD = indexSD[0]
;indices = indices[indNonSD]
;PRINT, 'Avaliable indices:' ;NDVI_mean NDVI_stdDev VH_mean VV_mean
;PRINT, indices
;PRINT, 'Selected_indices'
;PRINT, selected_indices

;prepare for output
IF (extract_pheno EQ 1) THEN BEGIN
  OPENW, lun, dir_out+'\pheno_results.csv',/GET_LUN
  OPENW, lunFail,dir_out+'\pheno_failures.txt',/GET_LUN
  ;PRINTF, lun, STRJOIN(['Index','CROP_TYPE','ID','Area','Lat','Lon','SOS20','EOS20','LSG20','SOS50','EOS50','LSG50', $
  PRINTF, lun, STRJOIN(['Index','CROP_TYPE','ID','Lat','Lon','SOS20','EOS20','LSG20','SOS50','EOS50','LSG50', $
                        'maxFitNDVI','Slope_growth','Slope_decay','r_fir','RMSD_fit',$
                        'nImages','maxGap', 'NDVI_SD_in_season',$
                        'p0','p1','p2','p3','p4','p5','p6','p0_err','p1_err','p2_err','p3_err','p4_err','p5_err','p6_err',$
                        'LocateSeason_code','LocateSeason_msg']+dlmtr)
ENDIF
cro_type= !NULL
sos20 = !NULL
maxFitNDVI = !NULL
eos20 = !NULL
eos50 = !NULL
lsg20 = !NULL
slopeUp = !NULL
slopeDown = !NULL

;for plotting color with latitude, make color table for lat
ctable = COLORTABLE(['red','blue'], NCOLORS = 256, /TRANSPOSE)
minLat = MIN(y.y)
maxLat = MAX(y.y)

;analyse crop by crop, for each crop:
FOR i = 0, N_ELEMENTS(selected_crops)-1 DO BEGIN
  indCrop = WHERE(y.crop EQ selected_crops[i], countCrop)
  IF (countCrop EQ 0) THEN STOP
  ;get the unique IDs of the crop
  tmp = y.pointID[indCrop]
  uniqIds = tmp[UNIQ(tmp, SORT(tmp))]
  PRINT, 'Elements for crop ' + selected_crops[i] + ': ' + STRTRIM(N_ELEMENTS(uniqIds),2)
  initHandlerInputDataGraphs = BYTARR(k_sub_max+1) ;initialize it at zero
  handlerInputDataGraphs = !NULL
;  initJk0 = 0
;  initJk1 = 0
;  initJk2 = 0 
  ;for each single id I have NDVI_mean  VH_mean VV_mean
  FOR j = 0, N_ELEMENTS(uniqIds)-1 DO BEGIN
    ;here we have k_sub_max+1 indexes to deal with
    FOR k = 0, k_sub_max DO BEGIN 

;      PRINT, 'remove debug stuff line 102xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'
;      u = where(uniqIds eq 55982498) ;29541898
;      j = u[0]
;      buffer_plots = 0
;      k = 0
;      PRINT, 'remove debug stuff line 102xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'
   
      ;treat the case of using ascending and descending seperately that do no exist as indexes (ASCENDING, DESCENDING are attributes of each obs
      index2retrieve = selected_indices[k]
      indexTitle = selected_indices[k] ;this is unchanged
      index2retrieve = STRSPLIT(index2retrieve,'_',/EXTRACT)    ;selected_indices = ['NDVIm', 'CR_ad', 'RVI_ad', 'CR_a', 'RVI_a', 'CR_d', 'RVI_d']
      ;if I get an string array of two elements it is S1 and the second elemnt tells me what orbit to use
      IF (N_ELEMENTS(index2retrieve) EQ 1) THEN BEGIN
        ;it is NDVI from S2
        ind = WHERE((y.pointID EQ uniqIds[j]) AND (y.s12 EQ 2), count)
        sentinel = 2
      ENDIF ELSE BEGIN
        ;it is S1 and we have 3 cases: use asc/desc, use asc only, use desc only
        CASE index2retrieve[1] OF
          'ad': ind = WHERE((y.pointID EQ uniqIds[j]) AND (y.s12 EQ 1), count)
          'a':  ind = WHERE((y.pointID EQ uniqIds[j]) AND (y.s12 EQ 1) AND (y.orbit EQ 'ASCENDING'), count)
          'd:': ind = WHERE((y.pointID EQ uniqIds[j]) AND (y.s12 EQ 1) AND (y.orbit EQ 'DESCENDING'), count)
          ELSE: stop
        ENDCASE
        index2retrieve = index2retrieve[0]
        sentinel = 1
      ENDELSE
        
      ;indOfNndviSD = WHERE((y.pointID EQ uniqIds[j]) AND (y.s12 EQ 2), count)
      ;get the date, NDVI, sd at max and area
      dateJD = y.dateJD[ind]
      v = y.(sub_tag_selected_indices[k])[ind];v is the index
      sd = y.NDVIsd[ind]
      ;order date ascending
      subAsc = SORT(dateJd)
      dateJd = dateJd[subAsc]
      v = v[subAsc]
      sd =sd[subAsc]     
      IF (sentinel EQ 1) THEN BEGIN
        ;s1 data, reduce with mean when there are more than one obs per day
        ;1 get unique jds
        uniqJDs = dateJd[UNIQ(dateJd, SORT(dateJd))]
        uv = FLTARR(N_ELEMENTS(uniqJDs))
        vMax = FLTARR(N_ELEMENTS(uniqJDs))
        vMin = FLTARR(N_ELEMENTS(uniqJDs))
        FOR u = 0, N_ELEMENTS(uniqJDs)-1 DO BEGIN
          indUjd = WHERE(dateJd EQ uniqJDs[u])
          uv[u] = MEAN(v[indUjd], /NAN)
          vMax[u] = MAX(v[indUjd], /NAN) ;max and min of that day
          vMin[u] = MIN(v[indUjd], /NAN)
        ENDFOR
        dateJd = uniqJDs
        v = uv
      ENDIF
      ;now remove possible NaN (important, it may cause troubles later when fitting)
      indFin = WHERE(FINITE(v))
      dateJd = dateJd[indFin]
      v = v[indFin]
      IF (sentinel EQ 1) THEN BEGIN
        vMax = vMax[indFin]
        vMin = vMin[indFin]
      ENDIF
      sd = sd[indFin] ;this is only for NDVI 
      ;area = y.buffer[ind[0]]
      PRINT, uniqIds[j], ', ',selected_crops[i], ', ', indexTitle
      ;get the latitude
      lat = y.y[ind[0]]
      lon = y.x[ind[0]]
      ;scale it in order to use it as a subscript of the colortable
      latSub = ROUND((lat-minLat)/FLOAT(maxLat-minLat)*255)
      ;make a plot with orginal data (all), extract title
      tmpTitle = STRTRIM(STRSPLIT(selected_crops[i], '-', /EXTRACT),2)
      IF (initHandlerInputDataGraphs[k] EQ 0) THEN BEGIN
        handlerInputDataGraphs = [handlerInputDataGraphs, PLOT(dateJd, v, XTICKFORMAT='(C(CDI,1x,CMoA,1x,CYI2))', NAME=selected_crops[i], COLOR = ctable[*,latSub], TRANSPARENCY= 95, $;LAYOUT=[1,3,i+1], $
          XTITLE='Time', YTITLE=indexTitle, DIMENSIONS=[1200,300], TITLE=tmpTitle[0], BUFFER = buffer_plots, XMINOR=5)]
        initHandlerInputDataGraphs[k] = 1
      ENDIF ELSE BEGIN
        handlerInputDataGraphs[k].Select
        handlerInputDataGraphs[k] = PLOT(dateJd, v, XTICKFORMAT='(C(CDI,1x,CMoA,1x,CYI2))', NAME=selected_crops[i], COLOR = ctable[*,latSub], TRANSPARENCY= 95, /OVERPLOT)
      ENDELSE
        
;      CASE k OF
;        0:BEGIN
;            ;IF (j EQ 0) THEN BEGIN
;            IF (initJk0 EQ 0) THEN BEGIN
;              hAll_k1 = PLOT(dateJd, v, XTICKFORMAT='(C(CDI,1x,CMoA,1x,CYI2))', NAME=selected_crops[i], COLOR = ctable[*,latSub], TRANSPARENCY= 95, $;LAYOUT=[1,3,i+1], $
;                XTITLE='Time', YTITLE=indexTitle,DIMENSIONS=[1200,300], TITLE=tmpTitle[0], BUFFER = buffer_plots, XMINOR=5)
;              initJk0 = 1
;            ENDIF ELSE BEGIN
;              hAll_k1.Select
;              hAll_k1 = PLOT(dateJd, v, XTICKFORMAT='(C(CDI,1x,CMoA,1x,CYI2))', NAME=selected_crops[i], COLOR = ctable[*,latSub], TRANSPARENCY= 95, /OVERPLOT)
;            ENDELSE
;          END
;        1:BEGIN
;            ;IF (j EQ 0) THEN BEGIN
;            IF (initJk1 EQ 0) THEN BEGIN
;              hAll_k2 = PLOT(dateJd, v, XTICKFORMAT='(C(CDI,1x,CMoA,1x,CYI2))', NAME=selected_crops[i], COLOR = ctable[*,latSub], TRANSPARENCY= 85, $;LAYOUT=[1,3,i+1], $
;                XTITLE='Time', YTITLE=indexTitle,DIMENSIONS=[1200,300], TITLE=tmpTitle[0], BUFFER = buffer_plots, XMINOR=5)
;              initJk1 = 1
;            ENDIF ELSE BEGIN
;              hAll_k2.Select
;              hAll_k2 = PLOT(dateJd, v, XTICKFORMAT='(C(CDI,1x,CMoA,1x,CYI2))', NAME=selected_crops[i], COLOR = ctable[*,latSub], TRANSPARENCY= 85, /OVERPLOT)
;            ENDELSE
;          END
;        2:BEGIN
;            ;IF (j EQ 0) THEN BEGIN
;            IF (initJk2 EQ 0) THEN BEGIN
;              hAll_k3 = PLOT(dateJd, v, XTICKFORMAT='(C(CDI,1x,CMoA,1x,CYI2))', NAME=selected_crops[i], COLOR = ctable[*,latSub], TRANSPARENCY= 85, $;LAYOUT=[1,3,i+1], $
;                XTITLE='Time', YTITLE=indexTitle,DIMENSIONS=[1200,300], TITLE=tmpTitle[0], BUFFER = buffer_plots, XMINOR=5)
;              initJk2 = 1
;            ENDIF ELSE BEGIN
;              hAll_k3.Select
;              hAll_k3 = PLOT(dateJd, v, XTICKFORMAT='(C(CDI,1x,CMoA,1x,CYI2))', NAME=selected_crops[i], COLOR = ctable[*,latSub], TRANSPARENCY= 85, /OVERPLOT)
;            ENDELSE
;          END
;        ELSE:STOP
;      ENDCASE
      
      IF (extract_pheno EQ 1) THEN BEGIN  
        IF (sentinel EQ 2) THEN BEGIN 
          ;for s2 plot sd
          h1 = ERRORPLOT(dateJd, v, sd, XTICKFORMAT='(C(CDI,1x,CMoA,1x,CYI2))', NAME=indexTitle, $
                  TITLE= selected_crops[i] + ', ID ' + STRTRIM(uniqIds[j],2) + ', Lat ' + STRTRIM(ROUND(lat),2), $
                  LINESTYLE='', SYMBOL='o', YTITLE=indexTitle, BUFFER = buffer_plots, DIMENSIONS=[900,300], XMINOR=5, /NODATA)
          h1 = ERRORPLOT(dateJd, v, sd, LINESTYLE='', SYMBOL='o', ERRORBAR_COLOR= 'grey', COLOR = 'grey', /OVERPLOT)
        ENDIF ELSE BEGIN
          ;for s1 plot min and max
          h1 = PLOT(dateJd, v, XTICKFORMAT='(C(CDI,1x,CMoA,1x,CYI2))', NAME=indexTitle, $
            TITLE= selected_crops[i] + ', ID ' + STRTRIM(uniqIds[j],2) + ', Lat ' + STRTRIM(ROUND(lat),2), $
            LINESTYLE='', SYMBOL='o', YTITLE=indexTitle, BUFFER = buffer_plots, DIMENSIONS=[900,300], XMINOR=5, /NODATA)
          h1 = PLOT(dateJd, v, LINESTYLE='', SYMBOL='o', COLOR = 'grey', /OVERPLOT)
          h1 = PLOT(dateJd, vMax, LINESTYLE='', SYMBOL='+', COLOR = 'grey', SYM_SIZE = 0.3, /OVERPLOT)
          h1 = PLOT(dateJd, vMin, LINESTYLE='', SYMBOL='+', COLOR = 'grey', SYM_SIZE = 0.3, /OVERPLOT)
        ENDELSE
        
        ;Anton: t = in Julian Dates (ENVI), NDVI should be double and have set values < 0 as noData
        ;Here I have to set the possible time. Let's try to understand if its summer or winter crop
        ;Find biggest max in the year of interest (given by Jd range) and the local minima at left and right, assuming that the max has to be located in the period of interest
        ;= year of interest betwen 1/1 and september 
        IF use_time_constrains_per_crop EQ 1 THEN BEGIN
          ;get the limits
          crop_code = STRSPLIT(selected_crops[i],'-', /EXTRACT)
          crop_code = STRTRIM(crop_code[-1], 2)
          indCrop = WHERE(timeRangesPerCrop.Code EQ crop_code, count)
          IF (count NE 1) THEN STOP
          DDMMrelY = STRSPLIT(timeRangesPerCrop.Left_min_limit[indCrop], '/', /EXTRACT)
          lmin = JULDAY(DDMMrelY[1],DDMMrelY[0],2018+FIX(DDMMrelY[2]))
          DDMMrelY = STRSPLIT(timeRangesPerCrop.Right_min_limit[indCrop], '/', /EXTRACT)
          rmin = JULDAY(DDMMrelY[1],DDMMrelY[0],2018+FIX(DDMMrelY[2]))
          DDMMrelY = STRSPLIT(timeRangesPerCrop.Left_max_limit[indCrop], '/', /EXTRACT)
          lmax = JULDAY(DDMMrelY[1],DDMMrelY[0],2018+FIX(DDMMrelY[2]))
          DDMMrelY = STRSPLIT(timeRangesPerCrop.Right_max_limit[indCrop], '/', /EXTRACT)
          rmax = JULDAY(DDMMrelY[1],DDMMrelY[0],2018+FIX(DDMMrelY[2]))
          season = locate_largest_season_in_jd_range_v3(dateJd, v, [lmin, rmin], [lmax,rmax], index2retrieve)
        ENDIF ELSE BEGIN
          season = locate_largest_season_in_jd_range_v3(dateJd, v, [JULDAY(01,01,2018), JULDAY(09,30,2018)], [JULDAY(03,01,2018), JULDAY(07,31,2018)], index2retrieve)
        ENDELSE
        ;treat retrieval `
        IF (season.retr EQ 1) THEN BEGIN
          dateRange = [dateJd[season.subLeft],dateJd[season.subRight]];[JULDAY(2,11,2016),JULDAY(2,15,2017)]  ; window range for finding phenology
          baseDate = JULDAY(01,01,2018)  ; base date for writing info (so 1 = 1 January x)
          ;pheno = phenoMainDouble(dateJd, v, 2, dateRange, baseDate) 
          pheno = phenoFitOverKnownInterval(dateJd, v, dateRange, dateJd[season.subMax], $
                                            season.ySmoothAtSubLeft, season.ySmoothAtSubRight, season.ySmoothAtSubMax, season.y_obs_smooth, $
                                            season.xjdLimP2, season.xjdLimP5, season.xjdFgP2, season.xjdFgP5, baseDate, index2retrieve)
          
          IF (pheno.retr EQ 1) THEN BEGIN
            ;plot and save only if it was successful
            dateTmp = INDGEN(pheno.jdInterval[1]-pheno.jdInterval[0])+pheno.jdInterval[0]     ; array with all days (JD) in the modelled year (automatically adapts for shorter years in case year started with decay)
            fitNDVIseries = TANH_DOUBLE(dateTmp,pheno.PARAM_X) 
            h1.Select 
            h2 = PLOT(dateTmp, fitNDVIseries, COLOR = ctable[*,latSub], NAME='DHT fit',/OVERPLOT)
            h3 = PLOT(baseDate+[pheno.SOS20,pheno.SOS20], [h2.yrange,h2.yrange], COLOR = 'green', NAME='SOS20',/OVERPLOT)
            h4 = PLOT(baseDate+[pheno.PS90,pheno.PS90], [h2.yrange,h2.yrange], COLOR = 'yellow', NAME='PS90',/OVERPLOT)
            ;season.subMax
            h6 = PLOT([dateJd[season.subMax],dateJd[season.subMax]], h2.yrange, COLOR = 'black', LINESTYLE='--', NAME='MaxOfSmooth',/OVERPLOT)
            xjd_reg = FINDGEN(dateJd[-1]-dateJd[0]+1)+dateJd[0] 
            h7 = PLOT(xjd_reg, season.y_reg_smooth, COLOR = 'black', NAME='ySmooth',TRANSPARENCY= 70, /OVERPLOT)
            ;h8 = PLOT(dateJd, season.y_obs_smooth, COLOR = 'black', NAME='ySmooth',LINESTYLE='',SYMBOL='o',TRANSPARENCY= 70, /OVERPLOT)
            IF FINITE(pheno.EOS20) THEN BEGIN
              h5 = PLOT(baseDate+[pheno.EOS20,pheno.EOS20], [h2.yrange,h2.yrange], COLOR = 'red', NAME='EOS20',/OVERPLOT)
              hl = LEGEND(TARGET=[h1,h2,h3,h4,h5,h6,h7], POSITION=[0.32,0.85], LINESTYLE='', TRANSPARENCY = 75)
            ENDIF ELSE BEGIN
              hl = LEGEND(TARGET=[h1,h2,h3,h4,h6,h7], POSITION=[0.32,0.85], LINESTYLE='', TRANSPARENCY = 75)
            ENDELSE
            indIn = WHERE((dateJd GE pheno.jdInterval[0]) AND (dateJd LE pheno.jdInterval[1]))
            IF (indexTitle EQ 'NDVIm') THEN $
               hTmp = ERRORPLOT(dateJd[indIn], v[indIn], sd[indIn], LINESTYLE='',SYMBOL='o', ERRORBAR_COLOR= 'black', COLOR = 'black', /OVERPLOT) $
              ELSE hTmp = PLOT(dateJd[indIn], v[indIn], LINESTYLE='',SYMBOL='o', ERRORBAR_COLOR= 'black', COLOR = 'black', /OVERPLOT) 
            sdAvg = MEAN(sd[indIn])
            ;for csv and xls, replace NaN with ''
            tmp = STRJOIN($
              ;[indexTitle, selected_crops[i], STRTRIM([uniqIds[j], area, lat, lon, pheno.SOS20, pheno.EOS20, pheno.LGS20, pheno.SOS50, pheno.EOS50, pheno.LGS50, pheno.maxNDVI,  $
              [indexTitle, selected_crops[i], STRTRIM([uniqIds[j], lat, lon, pheno.SOS20, pheno.EOS20, pheno.LGS20, pheno.SOS50, pheno.EOS50, pheno.LGS50, pheno.maxNDVI,  $
              ;'LSG20','Slope_growth','Slope_decay','r_fir','RMSD_fit','nImages','maxGap']) $
              pheno.PARAM_x[3], pheno.PARAM_x[6], pheno.PearsonCC, pheno.RMSD, pheno.nImages, pheno.maxGap, sdAvg, pheno.PARAM_X, pheno.PCERROR],2),STRTRIM(season.code,2),season.msg] $
              +dlmtr)
            tmp = tmp.Replace('NaN','')
            PRINTF, lun, tmp  
            cro_type= [cro_type, selected_crops[i]]
            sos20 = [sos20,pheno.SOS20]
            maxFitNDVI = [maxFitNDVI, pheno.maxNDVI]
            eos20 = [eos20, pheno.EOS20]
            eos50 = [eos50, pheno.eos50]
            lsg20 = [lsg20,  pheno.LGS20]
            slopeUp = [slopeUp,pheno.PARAM_x[3]]
            slopeDown = [slopeDown, pheno.PARAM_x[6]]
          ENDIF ELSE BEGIN ;pheno failed 
            PRINTF, lunFail, indexTitle + ',' + selected_crops[i] + ', ID ' + STRTRIM(uniqIds[j],2) + ', fit failed: ' + pheno.message
            pheno = 0
          ENDELSE
        ENDIF ELSE BEGIN ;locate_largest_season_in_jd_range failed 
          PRINTF, lunFail, indexTitle + ',' + selected_crops[i] + ', ID ' + STRTRIM(uniqIds[j],2) + ', LocateSeason failed: ' + season.msg
          season = 0
        ENDELSE
        h1.save, dir_out + '\fit_' + selected_crops[i] + '_ID_' + STRTRIM(uniqIds[j],2)+'_'+indexTitle+'.png'
        h1.close
        pheno = 0
      ENDIF ;extract_pheno
    ENDFOR  ;k 
  ENDFOR ;j
  ;PRINT, 'debug'
  FOR k = 0, k_sub_max DO BEGIN
    handlerInputDataGraphs[k].Select
    IF (k EQ 0) THEN handlerInputDataGraphs[k].YRANGE = [-0.2,1]
    cbar = COLORBAR(RGB_TABLE=ctable, ORIENTATION = 1, RANGE=[minLat,maxLat], TITLE='Latitude N (deg)',FONT_SIZE=fs,TAPER=1,POSITION = [0.97, 0.2, 0.99, 0.8])
    handlerInputDataGraphs[k].save, dir_out + '\All_input_data_'+selected_crops[i]+'_'+selected_indices[k]+'.png'
    handlerInputDataGraphs[k].close
  ENDFOR  
ENDFOR  ;i
IF (extract_pheno EQ 1) THEN BEGIN
  SAVE, /ALL, FILENAME = dir_out + '\pheno_run.sav'
  FREE_LUN, lun
  FREE_LUN, lunFail
ENDIF
PRINT, 'Ended'
END