PRO RAPHAEL_pheno_v3_sequential_caller
;with this procedure pheno is called sequentially without bridges
fn_sav = 'D:\RAPHAEL_pheno_test\LUCAS_S1-S2_extraction_20190520_v3.sav'
RESTORE, fn_sav
cropTypes = y.crop[UNIQ(y.crop,SORT(y.crop))]
y = 0
ncrops = N_ELEMENTS(cropTypes)
c = 0
PRINT, 'n unique crops = ', STRING(N_ELEMENTS(cropTypes))
selected_crops = cropTypes
;put common wheat first for easy debug
selected_crops = [selected_crops[3], selected_crops[0:2], selected_crops[4:-1]]
PRINT, selected_crops
use_time_constrains_per_crop = 1     ;set it to 1 to have time period (used by locate_largest_season_in_jd_range_v2) per crop
;time constrain per crop if required
IF (use_time_constrains_per_crop EQ 1) THEN BEGIN
  fn = FILE_DIRNAME(fn_sav) + '\time_constrains_per_crop.csv'
  res = READ_CSV(fn, HEADER=hdr)
  timeRangesPerCrop = rename_tags(res, TAG_NAMES(res), hdr)
  fn_timeConstrains = FILE_DIRNAME(fn) + '\' +FILE_BASENAME(fn, '.csv') + '.sav';STRSPLIT(csv_file, '.', /EXTRACT)
  SAVE, timeRangesPerCrop, FILENAME = fn_timeConstrains
ENDIF ELSE fn_timeConstrains = ''

stime = SYSTIME()
stimeStr = STRMID(stime,20,4) + STRMID(stime,4,3) + STRMID(stime,8,2)
dir_out = FILE_DIRNAME(fn_sav) + '\Results_' + stimeStr
IF FILE_SEARCH(dir_out) EQ '' THEN BEGIN
  FILE_MKDIR, dir_out
ENDIF ELSE BEGIN
  PRINT, 'Directory already exists, the program will overwrite it'
  FILE_MKDIR, dir_out
ENDELSE
dir_out_graphs = dir_out + '\graphs'
FILE_MKDIR, dir_out_graphs
FOR i = 0, N_ELEMENTS(selected_crops)-1 DO RAPHAEL_pheno_v3_bridge, selected_crops[i], i, fn_sav, dir_out, dir_out_graphs, use_time_constrains_per_crop, fn_timeConstrains
END


PRO RAPHAEL_pheno_v3_bridge_caller
fn_sav = 'D:\RAPHAEL_pheno_test\LUCAS_S1-S2_extraction_20190520_v3.sav'
RESTORE, fn_sav
cropTypes = y.crop[UNIQ(y.crop,SORT(y.crop))]
y = 0
ncrops = N_ELEMENTS(cropTypes)
c = 0
PRINT, 'n unique crops = ', STRING(N_ELEMENTS(cropTypes))
selected_crops = cropTypes
;put common wheat first for easy debug
selected_crops = [selected_crops[3], selected_crops[0:2], selected_crops[4:-1]]
PRINT, selected_crops
use_time_constrains_per_crop = 1     ;set it to 1 to have time period (used by locate_largest_season_in_jd_range_v2) per crop
;time constrain per crop if required
IF (use_time_constrains_per_crop EQ 1) THEN BEGIN
  fn = FILE_DIRNAME(fn_sav) + '\time_constrains_per_crop.csv'
  res = READ_CSV(fn, HEADER=hdr)
  timeRangesPerCrop = rename_tags(res, TAG_NAMES(res), hdr)
  fn_timeConstrains = FILE_DIRNAME(fn) + '\' +FILE_BASENAME(fn, '.csv') + '.sav';STRSPLIT(csv_file, '.', /EXTRACT)
  SAVE, timeRangesPerCrop, FILENAME = fn_timeConstrains
ENDIF ELSE fn_timeConstrains = ''


;Set up of IDL bridge
nPro = 12                                         ;number of process, up to a maximum number equal the number of virtual processor cores
;c=7 ;floric only 2 samples ok for debug
parallelProName = 'RAPHAEL_pheno_v3_bridge'     ;name of the function to be executed in parallel.
                                                ;IMPORTANT: this function MUST be positioned in the IDL path (Window-Preferences IDL-Paths) with all the required functions
;Some housekeeping for the bridges
oIDLBridgeArray = OBJARR(nPro)      ;array of Bridge objects, one object = one child process that can be executed
status = LONARR(nPro)               ;array for storing the status of the childs
ErrorString=STRARR(nPro)            ;array for storing potential problems of the child
inactive = BYTARR(nPro)             ;array to store the lifecycle of each child, it is turned to 1 when no more results are expected from this child
lastAssigment = STRARR(nPro)        ;array for storing the last crop assigned
stime = SYSTIME()
stimeStr = STRMID(stime,20,4) + STRMID(stime,4,3) + STRMID(stime,8,2)
dir_out = FILE_DIRNAME(fn_sav) + '\Results_' + stimeStr
IF FILE_SEARCH(dir_out) EQ '' THEN BEGIN
  FILE_MKDIR, dir_out
ENDIF ELSE BEGIN
  PRINT, 'Directory already exists, the program will overwrite it'
  FILE_MKDIR, dir_out
ENDELSE
;dir to output graphs
dir_out_graphs = dir_out + '\graphs'
FILE_MKDIR, dir_out_graphs
;Initialize childs
FOR i = 0, nPro-1 DO BEGIN
  oIDLBridgeArray[i] = OBJ_NEW("IDL_IDLBridge", OUTPUT=dir_out+'\out_'+STRTRIM(i,2)+'.txt')
  IF (~OBJ_VALID(oIDLBridgeArray[i])) THEN BEGIN
    void=DIALOG_MESSAGE(/ERROR,'Unable to create an IDL_IDLBridge session')
    WIDGET_CONTROL, wWrapper, /DESTROY
    RETURN
  ENDIF
  PRINT, 'Child process ' + STRTRIM(i,2) + ' was initialized'
ENDFOR
tt=systime(/sec)

;Start by assigning a a crop to each child
FOR i = 0, nPro-1 DO BEGIN
  PRINT, 'Child ' + STRTRIM(i, 2) + ' assigned to ' + selected_crops[c]
  lastAssigment[i] = selected_crops[c]
  oIDLBridgeArray[i]->SetVar, 'crop2process', selected_crops[c]
  oIDLBridgeArray[i]->SetVar, 'c', c
  oIDLBridgeArray[i]->SetVar, 'fn_sav', fn_sav
  oIDLBridgeArray[i]->SetVar, 'dir_out', dir_out
  oIDLBridgeArray[i]->SetVar, 'dir_out_graphs', dir_out_graphs
  oIDLBridgeArray[i]->SetVar, 'use_time_constrains_per_crop', use_time_constrains_per_crop
  oIDLBridgeArray[i]->SetVar, 'fn_timeConstrains', fn_timeConstrains
  ;oIDLBridgeArray[i]->Execute, 'res=' + parallelProName + '(crop2process, c, fn_sav)', /NOWAIT
  ;oIDLBridgeArray[i]->SetProperty, USERDATA=c
  oIDLBridgeArray[i]->Execute, parallelProName + ', crop2process, c, fn_sav, dir_out, dir_out_graphs, use_time_constrains_per_crop, fn_timeConstrains', /NOWAIT
  ;oIDLBridgeArray[i]->Execute, ' RAPHAEL_pheno_v3_bridge, crop2process, c, fn_sav', /NOWAIT
  c = c + 1 ;get reday for the next crop type
ENDFOR



eop = 0     ;end of processes: it turns 1 when there are no more processes to be assigned to a child (but childs may be running)
eor = 0     ;end of results: it turns 1 when eop = 1 (nothing to assign) and the results were gathered for all child, so exit the loop

;now test who is idle and let him process a new line, in the test loop take care of eor and eop conditions
WHILE eor EQ 0 DO BEGIN
  ;get the status of the childs
  FOR i = 0, nPro-1 DO BEGIN
    error = ''
    status[i]=oIDLBridgeArray[i]->Status(ERROR=error)
    ErrorString[i] = error
;    WAIT, 0.2
;    PRINT,'err = ' + err
  ENDFOR

  ;check if I have problems
  indFail = WHERE(status GE 3, countFail)
  IF (countFail GT 0) THEN BEGIN    ;strange: casting status[k] to string resulted in this symbol 
    FOR k = 0, countFail-1 DO BEGIN
      PRINT, 'Problem with child ' + STRTRIM(indFail[k],2) + ', Status = '+ STRTRIM(status[indFail[k]],2) + ', ErrorString: ' + ErrorString[indFail[k]]
      STOP
;      IF (ErrorString[indFail[k]] NE 'Type conversion error: Unable to convert given STRING to Long.') THEN STOP
    ENDFOR
    ;STOP
  ENDIF

  ;get inedex of those that have finished
  indIdle = WHERE(status EQ 0, countIdle)
  ;if some of them has finished
  IF (countIdle GT 0) THEN BEGIN
    FOR j = 0, countIdle-1 DO BEGIN
      ;in case we have finished the jobs, set them to inactive
      IF (eop EQ 1) THEN BEGIN
        ;no more new executions needed, set it to inactive
        inactive[indIdle[j]] = 1        
      ENDIF
      ;if all are inactive there is nothing left to do, set eor to 1 to get out of the cycle
      IF (TOTAL(inactive) EQ nPro) THEN eor = 1
    ENDFOR
  ENDIF
  IF ((countIdle GT 0) AND (eop EQ 0)) THEN BEGIN  
    ;if there are still jobs to be processed, launch a new execution
    ;run a new process using the  idle childs
    FOR j = 0, countIdle-1 DO BEGIN
      PRINT, 'Child' + STRTRIM(indIdle[j], 2) + ' (' + lastAssigment[indIdle[j]] + ') ended'
      IF (eop EQ 0) THEN BEGIN
        PRINT, 'Child ' + STRTRIM(indIdle[j], 2) + ' assigned to ' + selected_crops[c]
        astAssigment[indIdle[j]] = selected_crops[c]
        oIDLBridgeArray[indIdle[j]]->SetVar, 'crop2process', selected_crops[c]
        oIDLBridgeArray[indIdle[j]]->SetVar, 'c', c
        oIDLBridgeArray[indIdle[j]]->SetVar, 'fn_sav', fn_sav
        oIDLBridgeArray[indIdle[j]]->SetVar, 'dir_out', dir_out
        oIDLBridgeArray[indIdle[j]]->SetVar, 'dir_out_graphs', dir_out_graphs
        oIDLBridgeArray[indIdle[j]]->SetVar, 'use_time_constrains_per_crop', use_time_constrains_per_crop
        oIDLBridgeArray[indIdle[j]]->SetVar, 'fn_timeConstrains', fn_timeConstrains
        oIDLBridgeArray[indIdle[j]]->Execute, parallelProName + ', crop2process, c, fn_sav, dir_out, dir_out_graphs, use_time_constrains_per_crop, fn_timeConstrains', /NOWAIT
        ;oIDLBridgeArray[indIdle[j]]->SetProperty, USERDATA=c
      ENDIF ;eops
      ;check if there are still jobs to do, in case set eop = 1
      IF (c EQ ncrops-1) THEN BEGIN
        eop = 1
        PRINT, 'No more childs to launch, the program is waiting the active child to end'
      ENDIF ELSE BEGIN
        c = c + 1 ;get reday for the next line
      ENDELSE
    ENDFOR  
  ENDIF
ENDWHILE
;wait for all to end and do the rest
OBJ_DESTROY, oIDLBridgeArray
PRINT, 'Parallel processing time with '+STRTRIM(nPro,2) + ' processors (hours):', (systime(/sec)-tt)/60.0/60.0
END


PRO RAPHAEL_pheno_v3_bridge, crop2process, c, fn_sav, dir_out, dir_out_graphs, use_time_constrains_per_crop, fn_timeConstrains
  ;COMPILE_OPT IDL2
  @cb_optimization.comm

  buffer_plots = 1 ;(0 to see them)
  extract_pheno = 1  ;with 0 just plots the input data in a single graph
  k_sub_max = 6     ;subscript of the last index to consider 0 is only first, 1 is vh vv ratio, and so on
  dlmtr = ','
  ;read the file. New format:
  ;y = CREATE_STRUCT('pointID', LONARR(ntot), 'dateJD', LONARR(ntot), 'x', FLTARR(ntot), 'y', FLTARR(ntot), 'nuts0', STRARR(ntot), $
  ;  'crop', STRARR(ntot), 'surveyDateJD', LONARR(ntot), 's12', BYTARR(ntot), $
  ;  'orbit', STRARR(ntot), 'CR', FLTARR(ntot), 'RVI', FLTARR(ntot), $
  ;  'NDVIm', FLTARR(ntot), 'NDVIsd', FLTARR(ntot))
  ;!!! BE CARE, THE FOLLOWING HAS TO MATCH WITH SAV STRUCTURE
  RESTORE, fn_sav
  
  IF (use_time_constrains_per_crop EQ 1) THEN RESTORE, fn_timeConstrains
  ;COMPULSORY TO USE '_' to separete the index and the orbit
  selected_indices = ['NDVIm', 'CR_ad', 'RVI_ad', 'CR_a', 'RVI_a', 'CR_d', 'RVI_d']

  tagNames = TAG_NAMES(y)
  sub_tag_selected_indices = BYTARR(N_ELEMENTS(selected_indices))

  FOR i = 0, N_ELEMENTS(selected_indices)-1 DO BEGIN
    tmp = STRSPLIT(selected_indices[i], '_', /EXTRACT)
    sub_tag_selected_indices[i] = WHERE(STRLOWCASE(tagNames) EQ STRLOWCASE(tmp[0]), count)
    IF (count EQ 0) THEN STOP
  ENDFOR

  ;; set aside sd, do not consider it as index to be processed but as an ancillary info
  ;PRINT, 'Set aside NDVI_stdDev'
  ;indSD = WHERE(indices EQ 'NDVI_stdDev')
  ;indNonSD = WHERE(indices NE 'NDVI_stdDev')
  ;indexSD = indices[indSD]
  ;indexSD = indexSD[0]
  ;indices = indices[indNonSD]
  ;PRINT, 'Avaliable indices:' ;NDVI_mean NDVI_stdDev VH_mean VV_mean
  ;PRINT, indices
  ;PRINT, 'Selected_indices'
  ;PRINT, selected_indices

  ;prepare for output
  IF (extract_pheno EQ 1) THEN BEGIN
    OPENW, lun, dir_out+'\pheno_results_'+crop2process+'_'+STRTRIM(c,2)+'.csv',/GET_LUN
    OPENW, lunMiss,dir_out+'\pheno_missing_data_'+crop2process+'_'+STRTRIM(c,2)+'.txt',/GET_LUN
    OPENW, lunFail,dir_out+'\pheno_failures_'+crop2process+'_'+STRTRIM(c,2)+'.txt',/GET_LUN
    ;PRINTF, lun, STRJOIN(['Index','CROP_TYPE','ID','Area','Lat','Lon','SOS20','EOS20','LSG20','SOS50','EOS50','LSG50', $
    PRINTF, lun, STRJOIN(['Index','CROP_TYPE','ID','Lat','Lon','SOS20','EOS20','LSG20','SOS50','EOS50','LSG50', $
      'maxFitNDVI','Slope_growth','Slope_decay','r_fir','RMSD_fit',$
      'nImages','maxGap', 'NDVI_SD_in_season',$
      'p0','p1','p2','p3','p4','p5','p6','p0_err','p1_err','p2_err','p3_err','p4_err','p5_err','p6_err',$
      'LocateSeason_code','LocateSeason_msg']+dlmtr)
  ENDIF
  cro_type= !NULL
  sos20 = !NULL
  maxFitNDVI = !NULL
  eos20 = !NULL
  eos50 = !NULL
  lsg20 = !NULL
  slopeUp = !NULL
  slopeDown = !NULL

  ;for plotting color with latitude, make color table for lat
  ctable = COLORTABLE(['red','blue'], NCOLORS = 256, /TRANSPOSE)
  minLat = MIN(y.y)
  maxLat = MAX(y.y)

  ;analyse the crop to be processed:

  indCrop = WHERE(y.crop EQ crop2process, countCrop)
  IF (countCrop EQ 0) THEN STOP
  ;get the unique IDs of the crop
  tmp = y.pointID[indCrop]
  uniqIds = tmp[UNIQ(tmp, SORT(tmp))]
  PRINT, 'Elements for crop ' + crop2process + ': ' + STRTRIM(N_ELEMENTS(uniqIds),2)
  initHandlerInputDataGraphs = BYTARR(k_sub_max+1) ;initialize it at zero
  handlerInputDataGraphs = !NULL

  ;for each single id I have NDVI_mean  VH_mean VV_mean
  FOR j = 0, N_ELEMENTS(uniqIds)-1 DO BEGIN
    ;here we have k_sub_max+1 indexes to deal with
    FOR k = 0, k_sub_max DO BEGIN

      ;      PRINT, 'remove debug stuff line 102xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'
      ;      u = where(uniqIds eq 55982498) ;29541898
      ;      j = u[0]
      ;      buffer_plots = 0
      ;      k = 0
      ;      PRINT, 'remove debug stuff line 102xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'

      ;treat the case of using ascending and descending seperately that do no exist as indexes (ASCENDING, DESCENDING are attributes of each obs
      index2retrieve = selected_indices[k]
      indexTitle = selected_indices[k] ;this is unchanged
      index2retrieve = STRSPLIT(index2retrieve,'_',/EXTRACT)    ;selected_indices = ['NDVIm', 'CR_ad', 'RVI_ad', 'CR_a', 'RVI_a', 'CR_d', 'RVI_d']
      ;if I get an string array of two elements it is S1 and the second elemnt tells me what orbit to use
      IF (N_ELEMENTS(index2retrieve) EQ 1) THEN BEGIN
        ;it is NDVI from S2
        ind = WHERE((y.pointID EQ uniqIds[j]) AND (y.s12 EQ 2), count)
        sentinel = 2
      ENDIF ELSE BEGIN
        ;it is S1 and we have 3 cases: use asc/desc, use asc only, use desc only
        CASE index2retrieve[1] OF
          'ad': ind = WHERE((y.pointID EQ uniqIds[j]) AND (y.s12 EQ 1), count)
          'a':  ind = WHERE((y.pointID EQ uniqIds[j]) AND (y.s12 EQ 1) AND (y.orbit EQ 'ASCENDING'), count)
          'd': ind = WHERE((y.pointID EQ uniqIds[j]) AND (y.s12 EQ 1) AND (y.orbit EQ 'DESCENDING'), count)
          ELSE: stop
        ENDCASE
        index2retrieve = index2retrieve[0]
        sentinel = 1
      ENDELSE

      ;indOfNndviSD = WHERE((y.pointID EQ uniqIds[j]) AND (y.s12 EQ 2), count)
      ;get the date, NDVI, sd at max and area
      dateJD = y.dateJD[ind]
      v = y.(sub_tag_selected_indices[k])[ind];v is the index
      sd = y.NDVIsd[ind]
      ;order date ascending
      subAsc = SORT(dateJd)
      dateJd = dateJd[subAsc]
      v = v[subAsc]
      sd =sd[subAsc]
      IF (sentinel EQ 1) THEN BEGIN
        ;s1 data, reduce with mean when there are more than one obs per day
        ;1 get unique jds
        uniqJDs = dateJd[UNIQ(dateJd, SORT(dateJd))]
        uv = FLTARR(N_ELEMENTS(uniqJDs))
        vMax = FLTARR(N_ELEMENTS(uniqJDs))
        vMin = FLTARR(N_ELEMENTS(uniqJDs))
        FOR u = 0, N_ELEMENTS(uniqJDs)-1 DO BEGIN
          indUjd = WHERE(dateJd EQ uniqJDs[u])
          uv[u] = MEAN(v[indUjd], /NAN)
          vMax[u] = MAX(v[indUjd], /NAN) ;max and min of that day
          vMin[u] = MIN(v[indUjd], /NAN)
        ENDFOR
        dateJd = uniqJDs
        v = uv
      ENDIF
      ;now remove possible NaN (important, it may cause troubles later when fitting)
      indFin = WHERE(FINITE(v))
      dateJd = dateJd[indFin]
      v = v[indFin]
      IF (sentinel EQ 1) THEN BEGIN
        vMax = vMax[indFin]
        vMin = vMin[indFin]
      ENDIF
      sd = sd[indFin] ;this is only for NDVI
      ;area = y.buffer[ind[0]]
      PRINT, uniqIds[j], ', ',crop2process, ', ', indexTitle
      ;get the latitude
      lat = y.y[ind[0]]
      lon = y.x[ind[0]]
      ;scale it in order to use it as a subscript of the colortable
      latSub = ROUND((lat-minLat)/FLOAT(maxLat-minLat)*255)
      ;make a plot with orginal data (all), extract title
      tmpTitle = STRTRIM(STRSPLIT(crop2process, '-', /EXTRACT),2)
      IF (initHandlerInputDataGraphs[k] EQ 0) THEN BEGIN
        handlerInputDataGraphs = [handlerInputDataGraphs, PLOT(dateJd, v, XTICKFORMAT='(C(CDI,1x,CMoA,1x,CYI2))', NAME=crop2process, COLOR = ctable[*,latSub], TRANSPARENCY= 95, $;LAYOUT=[1,3,i+1], $
          XTITLE='Time', YTITLE=indexTitle, DIMENSIONS=[1200,300], TITLE=tmpTitle[0], BUFFER = buffer_plots, XMINOR=5)]
        initHandlerInputDataGraphs[k] = 1
      ENDIF ELSE BEGIN
        handlerInputDataGraphs[k].Select
        handlerInputDataGraphs[k] = PLOT(dateJd, v, XTICKFORMAT='(C(CDI,1x,CMoA,1x,CYI2))', NAME=crop2process, COLOR = ctable[*,latSub], TRANSPARENCY= 95, /OVERPLOT)
      ENDELSE


      IF (extract_pheno EQ 1) THEN BEGIN
        ;first check that there are at least 10 obs, if not add it to mising
        indTmp = WHERE(FINITE(v), counTmp)
        IF (counTmp LT 10) THEN BEGIN
          PRINTF, lunMiss, indexTitle + ',' + crop2process + ', ID ' + STRTRIM(uniqIds[j],2) + ', had less than 10 obs and it was not processed'
        ENDIF ELSE BEGIN
          IF (sentinel EQ 2) THEN BEGIN
            ;for s2 plot sd
            h1 = ERRORPLOT(dateJd, v, sd, XTICKFORMAT='(C(CDI,1x,CMoA,1x,CYI2))', NAME=indexTitle, $
              TITLE= crop2process + ', ID ' + STRTRIM(uniqIds[j],2) + ', Lat ' + STRTRIM(ROUND(lat),2), $
              LINESTYLE='', SYMBOL='o', YTITLE=indexTitle, BUFFER = buffer_plots, DIMENSIONS=[900,300], XMINOR=5, /NODATA)
            h1 = ERRORPLOT(dateJd, v, sd, LINESTYLE='', SYMBOL='o', ERRORBAR_COLOR= 'grey', COLOR = 'grey', /OVERPLOT)
          ENDIF ELSE BEGIN
            ;for s1 plot min and max
            h1 = PLOT(dateJd, v, XTICKFORMAT='(C(CDI,1x,CMoA,1x,CYI2))', NAME=indexTitle, $
              TITLE= crop2process + ', ID ' + STRTRIM(uniqIds[j],2) + ', Lat ' + STRTRIM(ROUND(lat),2), $
              LINESTYLE='', SYMBOL='o', YTITLE=indexTitle, BUFFER = buffer_plots, DIMENSIONS=[900,300], XMINOR=5, /NODATA)
            h1 = PLOT(dateJd, v, LINESTYLE='', SYMBOL='o', COLOR = 'grey', /OVERPLOT)
            h1 = PLOT(dateJd, vMax, LINESTYLE='', SYMBOL='+', COLOR = 'grey', SYM_SIZE = 0.3, /OVERPLOT)
            h1 = PLOT(dateJd, vMin, LINESTYLE='', SYMBOL='+', COLOR = 'grey', SYM_SIZE = 0.3, /OVERPLOT)
          ENDELSE

          ;Anton: t = in Julian Dates (ENVI), NDVI should be double and have set values < 0 as noData
          ;Here I have to set the possible time. Let's try to understand if its summer or winter crop
          ;Find biggest max in the year of interest (given by Jd range) and the local minima at left and right, assuming that the max has to be located in the period of interest
          ;= year of interest betwen 1/1 and september
          IF use_time_constrains_per_crop EQ 1 THEN BEGIN
            ;get the limits
            crop_code = STRSPLIT(crop2process,'-', /EXTRACT)
            crop_code = STRTRIM(crop_code[-1], 2)
            indCrop = WHERE(timeRangesPerCrop.Code EQ crop_code, count)
            IF (count NE 1) THEN STOP
            DDMMrelY = STRSPLIT(timeRangesPerCrop.Left_min_limit[indCrop], '/', /EXTRACT)
            lmin = JULDAY(DDMMrelY[1],DDMMrelY[0],2018+FIX(DDMMrelY[2]))
            DDMMrelY = STRSPLIT(timeRangesPerCrop.Right_min_limit[indCrop], '/', /EXTRACT)
            rmin = JULDAY(DDMMrelY[1],DDMMrelY[0],2018+FIX(DDMMrelY[2]))
            DDMMrelY = STRSPLIT(timeRangesPerCrop.Left_max_limit[indCrop], '/', /EXTRACT)
            lmax = JULDAY(DDMMrelY[1],DDMMrelY[0],2018+FIX(DDMMrelY[2]))
            DDMMrelY = STRSPLIT(timeRangesPerCrop.Right_max_limit[indCrop], '/', /EXTRACT)
            rmax = JULDAY(DDMMrelY[1],DDMMrelY[0],2018+FIX(DDMMrelY[2]))
            season = locate_largest_season_in_jd_range_v3(dateJd, v, [lmin, rmin], [lmax,rmax], index2retrieve)
          ENDIF ELSE BEGIN
            season = locate_largest_season_in_jd_range_v3(dateJd, v, [JULDAY(01,01,2018), JULDAY(09,30,2018)], [JULDAY(03,01,2018), JULDAY(07,31,2018)], index2retrieve)
          ENDELSE
          ;treat retrieval `
          IF (season.retr EQ 1) THEN BEGIN
            dateRange = [dateJd[season.subLeft],dateJd[season.subRight]];[JULDAY(2,11,2016),JULDAY(2,15,2017)]  ; window range for finding phenology
            baseDate = JULDAY(01,01,2018)  ; base date for writing info (so 1 = 1 January x)
            ;pheno = phenoMainDouble(dateJd, v, 2, dateRange, baseDate)
            pheno = phenoFitOverKnownInterval(dateJd, v, dateRange, dateJd[season.subMax], $
              season.ySmoothAtSubLeft, season.ySmoothAtSubRight, season.ySmoothAtSubMax, season.y_obs_smooth, $
              season.xjdLimP2, season.xjdLimP5, season.xjdFgP2, season.xjdFgP5, baseDate, index2retrieve, crop2process, uniqIds[j])

            IF (pheno.retr EQ 1) THEN BEGIN
              ;plot and save only if it was successful
              dateTmp = INDGEN(pheno.jdInterval[1]-pheno.jdInterval[0])+pheno.jdInterval[0]     ; array with all days (JD) in the modelled year (automatically adapts for shorter years in case year started with decay)
              fitNDVIseries = TANH_DOUBLE(dateTmp,pheno.PARAM_X)
              h1.Select
              h2 = PLOT(dateTmp, fitNDVIseries, COLOR = ctable[*,latSub], NAME='DHT fit',/OVERPLOT)
              h3 = PLOT(baseDate+[pheno.SOS20,pheno.SOS20], [h2.yrange,h2.yrange], COLOR = 'green', NAME='SOS20',/OVERPLOT)
              h4 = PLOT(baseDate+[pheno.PS90,pheno.PS90], [h2.yrange,h2.yrange], COLOR = 'yellow', NAME='PS90',/OVERPLOT)
              ;season.subMax
              h6 = PLOT([dateJd[season.subMax],dateJd[season.subMax]], h2.yrange, COLOR = 'black', LINESTYLE='--', NAME='MaxOfSmooth',/OVERPLOT)
              xjd_reg = FINDGEN(dateJd[-1]-dateJd[0]+1)+dateJd[0]
              h7 = PLOT(xjd_reg, season.y_reg_smooth, COLOR = 'black', NAME='ySmooth',TRANSPARENCY= 70, /OVERPLOT)
              ;h8 = PLOT(dateJd, season.y_obs_smooth, COLOR = 'black', NAME='ySmooth',LINESTYLE='',SYMBOL='o',TRANSPARENCY= 70, /OVERPLOT)
              IF FINITE(pheno.EOS20) THEN BEGIN
                h5 = PLOT(baseDate+[pheno.EOS20,pheno.EOS20], [h2.yrange,h2.yrange], COLOR = 'red', NAME='EOS20',/OVERPLOT)
                hl = LEGEND(TARGET=[h1,h2,h3,h4,h5,h6,h7], POSITION=[0.32,0.85], LINESTYLE='', TRANSPARENCY = 75)
              ENDIF ELSE BEGIN
                hl = LEGEND(TARGET=[h1,h2,h3,h4,h6,h7], POSITION=[0.32,0.85], LINESTYLE='', TRANSPARENCY = 75)
              ENDELSE
              indIn = WHERE((dateJd GE pheno.jdInterval[0]) AND (dateJd LE pheno.jdInterval[1]))
              IF (indexTitle EQ 'NDVIm') THEN $
                hTmp = ERRORPLOT(dateJd[indIn], v[indIn], sd[indIn], LINESTYLE='',SYMBOL='o', ERRORBAR_COLOR= 'black', COLOR = 'black', /OVERPLOT) $
              ELSE hTmp = PLOT(dateJd[indIn], v[indIn], LINESTYLE='',SYMBOL='o', ERRORBAR_COLOR= 'black', COLOR = 'black', /OVERPLOT)
              sdAvg = MEAN(sd[indIn])
              ;for csv and xls, replace NaN with ''
              tmp = STRJOIN($
                ;[indexTitle, crop2process, STRTRIM([uniqIds[j], area, lat, lon, pheno.SOS20, pheno.EOS20, pheno.LGS20, pheno.SOS50, pheno.EOS50, pheno.LGS50, pheno.maxNDVI,  $
                [indexTitle, crop2process, STRTRIM(uniqIds[j],2),STRTRIM([lat, lon, pheno.SOS20, pheno.EOS20, pheno.LGS20, pheno.SOS50, pheno.EOS50, pheno.LGS50, pheno.maxNDVI,  $
                ;'LSG20','Slope_growth','Slope_decay','r_fir','RMSD_fit','nImages','maxGap']) $
                pheno.PARAM_x[3], pheno.PARAM_x[6], pheno.PearsonCC, pheno.RMSD, pheno.nImages, pheno.maxGap, sdAvg, pheno.PARAM_X, pheno.PCERROR],2),STRTRIM(season.code,2),season.msg] $
                +dlmtr)
              tmp = tmp.Replace('NaN','')
              PRINTF, lun, tmp
              cro_type= [cro_type, crop2process]
              sos20 = [sos20,pheno.SOS20]
              maxFitNDVI = [maxFitNDVI, pheno.maxNDVI]
              eos20 = [eos20, pheno.EOS20]
              eos50 = [eos50, pheno.eos50]
              lsg20 = [lsg20,  pheno.LGS20]
              slopeUp = [slopeUp,pheno.PARAM_x[3]]
              slopeDown = [slopeDown, pheno.PARAM_x[6]]
            ENDIF ELSE BEGIN ;pheno failed
              PRINTF, lunFail, indexTitle + ',' + crop2process + ', ID ' + STRTRIM(uniqIds[j],2) + ', fit failed: ' + pheno.message
              pheno = 0
            ENDELSE
          ENDIF ELSE BEGIN ;locate_largest_season_in_jd_range failed
            PRINTF, lunFail, indexTitle + ',' + crop2process + ', ID ' + STRTRIM(uniqIds[j],2) + ', LocateSeason failed: ' + season.msg
            season = 0
          ENDELSE
          h1.save, dir_out_graphs + '\fit_' + crop2process + '_ID_' + STRTRIM(uniqIds[j],2)+'_'+indexTitle+'.png'
          h1.close
          pheno = 0
        ENDELSE ; it had more than 10 obs
      ENDIF ;extract_pheno
    ENDFOR  ;k
  ENDFOR ;j
  FOR k = 0, k_sub_max DO BEGIN
    handlerInputDataGraphs[k].Select
    IF (k EQ 0) THEN handlerInputDataGraphs[k].YRANGE = [-0.2,1]
    cbar = COLORBAR(RGB_TABLE=ctable, ORIENTATION = 1, RANGE=[minLat,maxLat], TITLE='Latitude N (deg)',FONT_SIZE=fs,TAPER=1,POSITION = [0.97, 0.2, 0.99, 0.8])
    handlerInputDataGraphs[k].save, dir_out_graphs + '\All_input_data_'+crop2process+'_'+selected_indices[k]+'.png'
    handlerInputDataGraphs[k].close
  ENDFOR

  IF (extract_pheno EQ 1) THEN BEGIN
    SAVE, /ALL, FILENAME = dir_out + '\pheno_run_'+crop2process+'_'+STRTRIM(c,2)+'.sav'
    FREE_LUN, lun
    FREE_LUN, lunFail
    FREE_LUN, lunMiss
  ENDIF
  ;WAIT, 20
  ;RETURN, '0'
END
